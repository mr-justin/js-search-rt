# Summary of the Project #

The purpose of js-search-rt is to write a search engine that performs all of the processing of an actual search on the client side while maintaining a data structure, a Radix Tree (http://en.wikipedia.org/wiki/Radix_tree), on the server side. The idea behind it is to reduce server loads and transform the server, when it comes to searching, into simply a file server. The client's browser performs all the work to process the search and uses the data attached to the keyword(s) to get the files from the results of the search. To do that, I designed it in two pieces. The first piece is a server side RESTful service that handles the creation and deletion of a Radix Tree data structure that contains keywords and their attached data. The second piece is the client side code that consumes a copy of the Radix Tree data structure in order to process the user's desired search string as they search. In some cases, the search can simply be employed for a single list-type page in order to toggle the user's desired results. In more advanced cases, the search can handle an index of an entire site to help the user navigate to the most appropriate page based on the results.

I have many reasons why I decided to create this project. I was looking for a practical example of designing more advanced data structures in JavaScript and JSON to expand my skills as a JavaScript developer. I reviewed the possibilities of other data structures but I felt that coding a more advanced tree structure would push my boundaries more than something like a hash table, lists, etc. Giving it a practical use case allowed me to formalize my approach so that it isn't just an attempt at designing something in the abstract. I was inspired by similar approaches and studies done by John Resig and Dave Ward on the Trie data structure in JavaScript, as it is very similar to the Radix Tree. In John Resig's article JavaScript Trie Performance Analysis (http://ejohn.org/blog/javascript-trie-performance-analysis/), he listed a possible optimization of the structure that resembled a Radix Tree. Inspired by that possible optimization, I started to build my interpretation of a Radix Tree that resembles that structure. The intent is to design a space-optimized data structure to increase network and browser performance. As you can see by John Resig's article, his performance analysis suggest that both of these items can be achieved through Tries and similar structures, like the Radix Tree. Gzipped file sizes of these structures that contain a dictionary of over 100,000 words are smaller than 300k in size! Initially my thoughts were purely on the client side, but as I learned more about advanced JavaScript OOP techniques, my ideas started to solidify into the state they are today.

The first piece of the system is the RESTful service in which the Radix Tree is created, maintained, and serves copies of it. I will be writing SearchCore.js to perform these duties. As you can see, SearchCore.js isn't written yet but RadixTree.js is written in JavaScript so I intend on building it as a module for node.js. I am still getting acclimated to node.js so this code may change a bit before the RESTful service is ready to be used. Essentially, RadixTree.js can currently handle inserting and removing keywords and data. It can build the resulting tree in JSON format to be served to the client side. I have prepared multiple examples of RadixTree.js using different design patterns in JavaScript. I felt that keeping it aligned with all of the features of JavaScript, a prototype-based object oriented language, would be the most appropriate. I am aware of the closure design pattern, and wrote one as an example, but I felt that the optimizations to the V8 engine for prototype or prototypal objects would be the best route to take. The reason why I decided to use the EMCAScript 5 methods is because of the new features, the usage of "use strict" and some of the new Object methods like Object.create to create RadixTree, and its helper objects Index and Callbacks, as well as Object.keys to detect whether a node is empty. I have also explored the changes to properties and descriptors in order to provide some level of privacy but still allowing some of the methods to be overwritten. RadixTree.js also employs other features of the JavaScript language. Everything is passed as a reference which made possible the simple objects, Index and Callbacks. The Index object was inspired by Java's Iterator object as it is essentially a helper object to help traverse the tree. It stores references to the current node and its parents on the tree during tree traversal to be used later in insertion and removal. The Callbacks object similarly holds references to the callback function calls to process the results of the tree traversal. Using the ability to pass values by reference and JavaScript callbacks, I was able to standardize the tree traversal code so that insertion and removal can share the same optimized code. It can also be extended to other potential processes for the tree such as modification of existing data or searching the tree against a search string.

The second piece of the system is the client side code that consumes a copy of the Radix Tree in order to search for the appropriate keyword(s) and provide a list of results or potential results to choose from. As I said above, initially my thoughts were purely on the client side, so much of the utility functions I have written can be reused in the client side code. Essentially the idea is to provide a Google-like search approach where exact keyword matches are cross-referenced with any potential partial keyword matches in order to provide real-time search suggestions and results. These results can be used in a variety of ways described above. For instance if the site has a list page, it can instantly toggle the display of any of the list items without more server interaction. It can also be used for a site's global search. For instance, it can catalog the keywords for a particular page and associate the URL with those keywords. The search suggestions can cross-reference the keywords in order to provide the most accurate page results in descending order. This piece is still under construction.

In conclusion, the purpose of js-search-rt is to write a search engine that performs all of the processing of the actual search on the client side while maintaining a Radix Tree data structure on the server side. The idea behind it is to reduce server loads and transform the server into simply a file server that processes requests. The client's browser performs all the work to process the search and uses the data attached to the keyword(s) to get the files from the results of the search. With a little imagination, the possibilities of js-search-rt and other JavaScript data structures are endless. Stay tuned for more to come!